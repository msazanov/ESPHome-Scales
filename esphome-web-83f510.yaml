substitutions:
  name: esphome-web-83f510
  friendly_name: ESPHome Web 83f510

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2024.6.0
  name_add_mac_suffix: false
  project:
    name: esphome.web
    version: dev
  on_boot:
    priority: -10
    then:
      - delay: 2s
      - lambda: |-
          id(is_calibrating) = true;
          id(calibration_type) = 0;  // Zero calibration
          id(calibration_in_progress) = true;
          id(calibration_state) = 0;
          id(display_page) = 3;  // Show calibration page during zero calibration
          ESP_LOGI("calibration", "Zero Calibration started at boot.");


esp32:
  board: seeed_xiao_esp32c3
  framework:
    type: arduino

logger:
  level: INFO
  logs:
    hx711: WARN
    sensor: WARN
    filter: WARN

api:
  password: ""

ota:
  - platform: esphome

wifi:
  ssid: "HighGadget"
  password: "Nirvana108"
  ap:
    ssid: "Dummyscales Fallback Hotspot"
    password: "YiGoo1Ful4VA"

captive_portal:

dashboard_import:
  package_import_url: github://esphome/firmware/esphome-web/esp32c3.yaml@main
  import_full_config: true

esp32_improv:
  authorizer: none

web_server:

i2c:
  sda: GPIO6
  scl: GPIO7
  scan: true
  frequency: 400kHz

globals:
  - id: tare_offset
    type: float
    initial_value: '0'

  - id: calibration_factor
    type: float
    restore_value: yes
    initial_value: '1.0'  # Adjusted initial value for testing

  - id: is_calibrating
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: calibration_type
    type: int
    restore_value: no
    initial_value: '0'  # 0 = calibration at 0g, 1 = calibration at 100g

  - id: dev_mode
    type: bool
    restore_value: yes
    initial_value: 'false'

  - id: display_page
    type: int
    restore_value: no
    initial_value: '1'  # 1 = normal page, 2 = dev page, 3 = calibration

  - id: last_published_raw_weight
    type: float
    restore_value: no
    initial_value: '0'

  - id: desired_sample_count
    type: int
    restore_value: no
    initial_value: '10'

  - id: sum_samples
    type: float
    restore_value: no
    initial_value: '0'

  - id: current_sample_count
    type: int
    restore_value: no
    initial_value: '0'

  - id: last_publish_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: last_published_weight
    type: float
    restore_value: no
    initial_value: '0'

  # New globals for calibration state management
  - id: calibration_in_progress
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: calibration_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: calibration_sample_count
    type: int
    restore_value: no
    initial_value: '0'

  - id: calibration_sum_samples
    type: float
    restore_value: no
    initial_value: '0'

  - id: calibration_state
    type: int
    restore_value: no
    initial_value: '0'  # 0 = Not calibrating, 1 = Waiting, 2 = Collecting samples

  - id: cal_prev_weight1
    type: float
    restore_value: no
    initial_value: '0'

  - id: cal_prev_weight2
    type: float
    restore_value: no
    initial_value: '0'

font:
  - file: "fonts/NotoSansMono-Regular.ttf"
    id: NotoSansMonoSmall
    size: 10
  - file: "fonts/pricedow.ttf"
    id: pricedow
    size: 64


switch:
  - platform: template
    name: "Developer Mode"
    id: dev_mode_switch
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(dev_mode) = true;
          id(display_page) = 2;
          ESP_LOGI("display", "Switched to Developer mode, page: %d", id(display_page));
          ESP_LOGI("display", "dev_mode is: %s", id(dev_mode) ? "true" : "false");
    turn_off_action:
      - lambda: |-
          id(dev_mode) = false;
          id(display_page) = 1;
          ESP_LOGI("display", "Switched to Normal mode, page: %d", id(display_page));
          ESP_LOGI("display", "dev_mode is: %s", id(dev_mode) ? "true" : "false");


sensor:
  - platform: hx711
    name: "Raw Weight"
    id: raw_weight
    internal: true
    dout_pin: GPIO4
    clk_pin: GPIO3
    update_interval: 200ms
    on_raw_value:
      then:
        - lambda: |-
            // Get current weight
            float current_weight = id(raw_weight)->state;

            // Static variables to store previous values
            static float prev_weight1 = current_weight;
            static float prev_weight2 = current_weight;

            // Check for single spike
            if (fabs(current_weight - prev_weight1) > 1000 && fabs(current_weight - prev_weight2) > 1000) {
              // Update previous values
              prev_weight2 = prev_weight1;
              prev_weight1 = current_weight;
              ESP_LOGW("filter", "Spike detected, skipping measurement: current=%.0f, prev1=%.0f, prev2=%.0f", current_weight, prev_weight1, prev_weight2);
              return;
            }

            // Update previous values
            prev_weight2 = prev_weight1;
            prev_weight1 = current_weight;

            if (id(is_calibrating)) {
              // Calibration logic
              if (id(calibration_state) == 0) {
                id(calibration_start_time) = millis();
                id(calibration_state) = 1;
                ESP_LOGI("calibration", "Waiting 1 second before starting calibration.");
              } else if (id(calibration_state) == 1) {
                if (millis() - id(calibration_start_time) >= 1000) {
                  id(calibration_state) = 2;
                  id(desired_sample_count) = 24;
                  id(calibration_sample_count) = 0;
                  id(calibration_sum_samples) = 0;
                  // Initialize spike detection variables
                  id(cal_prev_weight1) = current_weight;
                  id(cal_prev_weight2) = current_weight;
                  ESP_LOGI("calibration", "Starting calibration sample collection.");
                }
              } else if (id(calibration_state) == 2) {
                // Spike detection during calibration
                if (fabs(current_weight - id(cal_prev_weight1)) > 1000 && fabs(current_weight - id(cal_prev_weight2)) > 1000) {
                  // Spike detected, reset calibration
                  id(calibration_state) = 1;
                  id(calibration_sample_count) = 0;
                  id(calibration_sum_samples) = 0;
                  ESP_LOGW("calibration", "Spike detected during calibration, restarting.");
                  return;
                }
                // Update previous weights for spike detection
                id(cal_prev_weight2) = id(cal_prev_weight1);
                id(cal_prev_weight1) = current_weight;

                // Accumulate samples
                id(calibration_sum_samples) += current_weight;
                id(calibration_sample_count) += 1;
                ESP_LOGI("calibration", "Collecting calibration samples: %d/%d", id(calibration_sample_count), id(desired_sample_count));

                if (id(calibration_sample_count) >= id(desired_sample_count)) {
                  // Calculate average
                  float average_weight = id(calibration_sum_samples) / id(desired_sample_count);

                  if (id(calibration_type) == 0) {
                    // Zero calibration
                    id(tare_offset) = average_weight;
                    ESP_LOGI("calibration", "Zero Calibration complete. Tare offset: %f", id(tare_offset));
                  } else if (id(calibration_type) == 1) {
                    // 100g calibration
                    float adjusted_weight = id(tare_offset) - average_weight;
                    if (adjusted_weight != 0) {
                      id(calibration_factor) = 100.0 / adjusted_weight;
                      ESP_LOGI("calibration", "Calibration complete. Factor: %f", id(calibration_factor));
                    } else {
                      ESP_LOGW("calibration", "Calibration failed: adjusted_weight is 0");
                    }
                  }
                  // End calibration
                  id(is_calibrating) = false;
                  id(calibration_in_progress) = false;
                  id(calibration_state) = 0;
                  id(display_page) = 1;
                  // Reset spike detection variables
                  id(cal_prev_weight1) = current_weight;
                  id(cal_prev_weight2) = current_weight;
                }
                return;
              }
              return;  // Prevent further processing during calibration
            }

            // Normal operation code
            // Calculate difference with last published raw weight
            float difference = fabs(current_weight - id(last_published_raw_weight));

            // Set desired sample count based on difference
            if (difference <= 100.0) {
              id(desired_sample_count) = 24;
            } else if (difference <= 500.0) {
              id(desired_sample_count) = 20;
            } else if (difference <= 1000.0) {
              id(desired_sample_count) = 16;
            } else if (difference <= 2000.0) {
              id(desired_sample_count) = 8;
            } else if (difference <= 4000.0) {
              id(desired_sample_count) = 6;
            } else if (difference <= 8000.0) {
              id(desired_sample_count) = 5;
            } else if (difference <= 16000.0) {
              id(desired_sample_count) = 4;
            } else if (difference <= 32000.0) {
              id(desired_sample_count) = 3;
            } else if (difference <= 64000.0) {
              id(desired_sample_count) = 2;
            } else {
              id(desired_sample_count) = 1;
            }

            // Accumulate samples
            id(sum_samples) += current_weight;
            id(current_sample_count) += 1;

            // Check if required number of samples is reached
            if (id(current_sample_count) >= id(desired_sample_count)) {
              // Calculate average value
              float average_weight = id(sum_samples) / id(desired_sample_count);

              // Reset sum and sample counter
              id(sum_samples) = 0;
              id(current_sample_count) = 0;

              // Calculate weight in grams considering calibration factor
              float grams = (id(tare_offset) - average_weight) * id(calibration_factor);

              // Automatic drift compensation
              if (fabs(grams) > 0.01 && fabs(grams) <= 0.1) {
                id(tare_offset) = average_weight;
                ESP_LOGI("auto_tare", "Automatic correction. New offset: %.0f", id(tare_offset));
                grams = (id(tare_offset) - average_weight) * id(calibration_factor);
              }

              // Stabilize display
              if (grams > -0.02 && grams < 0.02) {
                grams = 0.00;
              }

              // Log all variables in one line
              ESP_LOGI("measurement", "Weight: %.2f g, Raw: %.0f, Offset: %.0f, Samples: %d", grams, average_weight, id(tare_offset), id(desired_sample_count));

              // Determine if we need to publish the value to Home Assistant
              unsigned long now = millis();
              float percentage_change = 0.0;
              if (fabs(id(last_published_weight)) > 0.001) {
                percentage_change = fabs(grams - id(last_published_weight)) / fabs(id(last_published_weight));
              } else {
                percentage_change = 1.0;
              }

              if ((now - id(last_publish_time)) >= 5000 || percentage_change >= 0.05) {
                id(grams_weight)->publish_state(grams);
                id(last_published_weight) = grams;
                id(last_publish_time) = now;
                id(last_published_raw_weight) = average_weight;
              }

              // Update raw data display
              id(raw_weight_display)->publish_state(average_weight);
            }

  - platform: template
    name: "Weight in Grams"
    id: grams_weight
    unit_of_measurement: "g"
    accuracy_decimals: 2
    update_interval: never

  - platform: template
    name: "Raw Weight Display"
    id: raw_weight_display
    internal: true
    unit_of_measurement: ""
    accuracy_decimals: 0
    update_interval: never

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO8
      mode: INPUT_PULLUP
    name: "Tare Button"
    on_click:
      # 100g Calibration
      - min_length: 6000ms
        max_length: 60000ms
        then:
          - lambda: |-
              ESP_LOGI("button", "100g Calibration Button Pressed");
              id(is_calibrating) = true;
              id(calibration_type) = 1;  // 100g calibration
              id(calibration_in_progress) = true;
              id(calibration_state) = 0;
              id(display_page) = 3;  // Show calibration page during 100g calibration
              ESP_LOGI("calibration", "Calibration started. Place 100g weight.");


      # Zero Calibration
      - min_length: 3000ms
        max_length: 6000ms
        then:
          - lambda: |-
              ESP_LOGI("button", "Zero Calibration Button Pressed");
              id(is_calibrating) = true;
              id(calibration_type) = 0;  // Zero calibration
              id(calibration_in_progress) = true;
              id(calibration_state) = 0;
              id(display_page) = 3;  // Show calibration page during zero calibration
              ESP_LOGI("calibration", "Zero Calibration started. Remove all weight.");

      # Tare
      - min_length: 50ms
        max_length: 3000ms
        then:
          - lambda: |-
              ESP_LOGI("button", "Tare Button Pressed");
              id(tare_offset) = id(raw_weight)->state;
              ESP_LOGI("tare_button", "Tare updated: %f", id(tare_offset));



display:
  - platform: ssd1306_i2c
    model: "SH1106 128x64"
    address: 0x3C
    update_interval: 100ms
    lambda: |-
      it.clear();
      if (id(display_page) == 1) {
        it.printf(0, 0, id(pricedow), "%.2f g", id(grams_weight)->state);
      } else if (id(display_page) == 2) {
        it.printf(0, 0, id(NotoSansMonoSmall), "Weight: %.2f g", id(grams_weight)->state);
        it.printf(0, 11, id(NotoSansMonoSmall), "Raw: %.0f", id(raw_weight_display)->state);
        it.printf(0, 22, id(NotoSansMonoSmall), "Tare: %.0f", id(tare_offset));
        it.printf(0, 33, id(NotoSansMonoSmall), "Samples: %d", id(desired_sample_count));
      } else if (id(display_page) == 3) {
        // Show calibration page during calibration
        if (id(calibration_type) == 1) {
          it.printf(0, 0, id(NotoSansMonoSmall), "Calibration 100g");
        } else if (id(calibration_type) == 0) {
          it.printf(0, 0, id(NotoSansMonoSmall), "Zero Calibration");
        }
        if (id(calibration_state) == 1) {
          it.printf(0, 16, id(NotoSansMonoSmall), "Starting in 1s...");
        } else if (id(calibration_state) == 2) {
          it.printf(0, 16, id(NotoSansMonoSmall), "Calibrating...");
          it.printf(0, 32, id(NotoSansMonoSmall), "Sample %d/%d", id(calibration_sample_count), id(desired_sample_count));
        } else {
          it.printf(0, 16, id(NotoSansMonoSmall), "Calibration Done");
        }
      }